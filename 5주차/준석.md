## 7장. 병렬 데이터 처리와 성능

## 7.1 병렬 스트림

컬렉션에 `parallelStream`을 호출하면 **병렬 스트림**이 생성됨. 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림을 말함. 따라서 병렬 스트림을 이용하면 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있음.

### 순차 스트림을 병렬 스트림으로 변환하기

```java
// 순차 스트림
public static long sequentialSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .reduce(0L, Long::sum);
}

// 병렬 스트림
public static long parallelSum(long n) {
    return Stream.iterate(1L, i -> i + 1)
        .limit(n)
        .parallel()  // 스트림을 병렬 스트림으로 변환
        .reduce(0L, Long::sum);
}
```

내부적으로 `parallel`을 호출하면 이후 연산이 병렬로 수행해야 함을 의미하는 불린 플래그가 설정됨. 반대로 `sequential`로 병렬 스트림을 순차 스트림으로 바꿀 수 있음.

```java
stream.parallel()
    .filter(...)
    .sequential()
    .map(...)
    .parallel()
    .reduce();
```

마지막에 호출된 메서드가 전체 파이프라인에 영향을 미침. 위 예제에서는 마지막에 `parallel()`이 호출되었으므로 파이프라인은 병렬로 실행됨.

### 병렬 스트림의 올바른 사용

병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어남.

```java
// 잘못된 예 - 상태를 공유하는 문제
public long sideEffectSum(long n) {
    Accumulator accumulator = new Accumulator();
    LongStream.rangeClosed(1, n).forEach(accumulator::add);
    return accumulator.total;
}

public class Accumulator {
    public long total = 0;
    public void add(long value) { total += value; }
}
```

위 코드는 본질적으로 순차 실행할 수 있도록 구현되어 있으므로 병렬로 실행하면 참사가 발생함. 특히 `total`을 접근할 때마다 (다수의 스레드에서 동시에 데이터에 접근하는) **데이터 레이스** 문제가 발생함.

### 병렬 스트림 효과적으로 사용하기

- 확신이 서지 않으면 직접 측정하라. 순차 스트림을 병렬 스트림으로 쉽게 바꿀 수 있지만 무조건 병렬 스트림으로 바꾸는 것이 능사는 아님
- 박싱을 주의하라. 오토박싱과 언박싱은 성능을 크게 저하시킬 수 있음. 자바 8은 박싱 동작을 피할 수 있도록 기본형 특화 스트림(`IntStream`, `LongStream`, `DoubleStream`)을 제공함
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있음. 특히 `limit`나 `findFirst`처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 함
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라. 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는 데 드는 비용이 Q라 하면 전체 스트림 파이프라인 처리 비용은 N\*Q임. Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미함
- 소량의 데이터에서는 병렬 스트림이 도움이 되지 않음
- 스트림을 구성하는 자료구조가 적절한지 확인하라. `ArrayList`는 `LinkedList`보다 효율적으로 분할할 수 있음. `LinkedList`는 분할하려면 모든 요소를 탐색해야 하지만 `ArrayList`는 요소를 탐색하지 않고도 리스트를 분할할 수 있음
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있음
- 최종 연산의 병합 과정 비용을 살펴보라. 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있음

---

## 7.2 포크/조인 프레임워크

**포크/조인 프레임워크**는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었음.

포크/조인 프레임워크에서는 서브태스크를 스레드 풀(`ForkJoinPool`)의 작업자 스레드에 분산 할당하는 `ExecutorService` 인터페이스를 구현함.

### RecursiveTask 활용

스레드 풀을 이용하려면 `RecursiveTask<R>`의 서브클래스를 만들어야 함. 여기서 R은 병렬화된 태스크가 생성하는 결과 형식 또는 결과가 없을 때는 `RecursiveAction` 형식임.

`RecursiveTask`를 정의하려면 추상 메서드 `compute`를 구현해야 함:

```java
protected abstract R compute();
```

`compute` 메서드는 태스크를 서브태스크로 분할하는 로직과 더 이상 분할할 수 없을 때 개별 서브태스크의 결과를 생산할 알고리즘을 정의함.

```
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함
    모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}
```

### 예제: ForkJoinSumCalculator

```java
public class ForkJoinSumCalculator extends RecursiveTask {
    private final long[] numbers;
    private final int start;
    private final int end;
    public static final long THRESHOLD = 10_000;  // 이 값 이하의 서브태스크는 더 이상 분할할 수 없음

    public ForkJoinSumCalculator(long[] numbers) {
        this(numbers, 0, numbers.length);
    }

    private ForkJoinSumCalculator(long[] numbers, int start, int end) {
        this.numbers = numbers;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        if (length <= THRESHOLD) {
            return computeSequentially();  // 기준값보다 작으면 순차적으로 결과를 계산
        }
        ForkJoinSumCalculator leftTask =
            new ForkJoinSumCalculator(numbers, start, start + length / 2);
        leftTask.fork();  // ForkJoinPool의 다른 스레드로 새로 생성한 태스크를 비동기로 실행
        ForkJoinSumCalculator rightTask =
            new ForkJoinSumCalculator(numbers, start + length / 2, end);
        Long rightResult = rightTask.compute();  // 두 번째 서브태스크를 동기 실행 (추가로 분할될 수 있음)
        Long leftResult = leftTask.join();  // 첫 번째 서브태스크의 결과를 읽거나 아직 결과가 없으면 기다림
        return leftResult + rightResult;
    }

    private long computeSequentially() {
        long sum = 0;
        for (int i = start; i < end; i++) {
            sum += numbers[i];
        }
        return sum;
    }
}
```

### 포크/조인 프레임워크를 제대로 사용하는 방법

- `join` 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출자를 블록시킴. 따라서 두 서브태스크가 모두 시작된 다음에 `join`을 호출해야 함
- `RecursiveTask` 내에서는 `ForkJoinPool`의 `invoke` 메서드를 사용하지 말아야 함. 대신 `compute`나 `fork` 메서드를 직접 호출할 수 있음. 순차 코드에서 병렬 계산을 시작할 때만 `invoke`를 사용함
- 서브태스크에 `fork` 메서드를 호출해서 `ForkJoinPool`의 일정을 조절할 수 있음. 왼쪽 작업과 오른쪽 작업 모두에 `fork` 메서드를 호출하는 것이 자연스러울 것 같지만 한쪽 작업에는 `fork`를 호출하는 것보다 `compute`를 호출하는 것이 효율적임
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어려움
- 멀티코어에 포크/조인 프레임워크를 사용하는 것이 순차 처리보다 무조건 빠를 것이라는 생각은 버려야 함

### 작업 훔치기

**작업 훔치기(work stealing)** 기법에서는 `ForkJoinPool`의 모든 스레드를 거의 공정하게 분할함. 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리함.

한 스레드는 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리할 수 있음. 할 일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐옴. 모든 태스크가 작업을 끝낼 때까지, 즉 모든 큐가 빌 때까지 이 과정을 반복함.

---

## 7.3 Spliterator 인터페이스

자바 8은 `Spliterator`라는 새로운 인터페이스를 제공함. **Spliterator**는 '분할할 수 있는 반복자(splitable iterator)'라는 의미임. `Iterator`처럼 `Spliterator`는 소스의 요소 탐색 기능을 제공한다는 점은 같지만 `Spliterator`는 병렬 작업에 특화되어 있음.

```java
public interface Spliterator {
    boolean tryAdvance(Consumer action);
    Spliterator trySplit();
    long estimateSize();
    int characteristics();
}
```

### Spliterator 메서드

- **tryAdvance**: `Spliterator`의 요소를 하나씩 순차적으로 소비하면서 탐색해야 할 요소가 남아있으면 참을 반환함
- **trySplit**: `Spliterator`의 일부 요소를 분할해서 두 번째 `Spliterator`를 생성함. 더 이상 분할할 요소가 없어서 `null`이 반환될 때까지 진행됨
- **estimateSize**: 탐색해야 할 요소 수 정보를 제공함
- **characteristics**: `Spliterator` 자체의 특성 집합을 포함하는 `int`를 반환함

### 분할 과정

스트림을 여러 스트림으로 분할하는 과정은 재귀적으로 일어남:

1. 첫 번째 `Spliterator`에 `trySplit`을 호출하면 두 번째 `Spliterator`가 생성됨
2. 두 개의 `Spliterator`에 `trySplit`을 다시 호출하면 네 개의 `Spliterator`가 생성됨
3. `trySplit`의 결과가 `null`이 될 때까지 이 과정을 반복함
4. `Spliterator`에 호출한 모든 `trySplit`의 결과가 `null`이면 재귀 분할 과정이 종료됨

### Spliterator 특성

`characteristics` 메서드는 `Spliterator` 자체의 특성 집합을 포함하는 `int`를 반환함:

- **ORDERED**: 리스트처럼 요소에 정해진 순서가 있으므로 `Spliterator`는 요소를 탐색하고 분할할 때 이 순서에 유의해야 함
- **DISTINCT**: x, y 두 요소를 방문했을 때 `x.equals(y)`는 항상 `false`를 반환함
- **SORTED**: 탐색된 요소는 미리 정의된 정렬 순서를 따름
- **SIZED**: 크기가 알려진 소스로 `Spliterator`를 생성했으므로 `estimateSize()`는 정확한 값을 반환함
- **NON-NULL**: 탐색하는 모든 요소는 `null`이 아님
- **IMMUTABLE**: 이 `Spliterator`의 소스는 불변임. 즉, 요소를 탐색하는 동안 요소를 추가, 삭제 또는 수정할 수 없음
- **CONCURRENT**: 동기화 없이 `Spliterator`의 소스를 여러 스레드에서 동시에 고칠 수 있음
- **SUBSIZED**: 이 `Spliterator` 그리고 분할되는 모든 `Spliterator`는 `SIZED` 특성을 가짐
