# 3. 람다 표현식
## 람다란 무엇인가?

### 개념

- 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이다.
- 람다 표현식에는 이름은 없지만 파라미터 리스트, 바디, 반환 형식, 예외 리스트는 가질 수 있다.

### **특징**

**익명**

- 보통의 메서드들과 달리 이름이 없으므로 익명이라 표현한다. 구현해야 할 코드에 대한 걱정거리가 줄어든다.

**함수**

- 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부른다.
- 하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.

**전달**

- 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.

**간결성**

- 익명 클래스처럼 자질구레한 코드를 구현할 필요가 없다.

### 구성

- 람다는 세 부분으로 이루어진다.

**파라미터 리스트**

- Comparator의 compare 메서드 파라미터

**화살표**

- 람다의 파라미터 리스트와 람다 바디를 구분

**람다 바디**

- 두 사과의 무게를 비교. 람다의 반환값에 해당하는 표현식

### 람다 문법

**표현식 스타일**

```java
(parameters) -> expression
```

**블록 스타일**

```java
(parameters) -> { statements; }
```

## 어디에, 어떻게 람다를 사용하는가?

### 함수형 인터페이스

- 람다 표현식은 함수형 인터페이스라는 문맥에서 사용할 수 있다.
- 함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 인터페이스다.

### 함수 디스크립터

- 함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
- 람다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다.

```java
public void process(Runnable r) {
    r.run();
}

process(() -> System.cout.println("This is awesome!"));
```

- 위 코드는 인수가 없으며 void를 반환하는 람다 표현식이다.
- 해당 코드의 함수 디스크립터 : () → void
- 이는 Runnable 인터페이스의 run 메서드 시그니처와 같다.

> **`@FunctionalInterface`**
> 
> @FunctionalInterface는 함수형 인터페이스임을 가리키는 어노테이션이다. 
> 해당 어노테이션이 붙은 인터페이스가 실제 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다.

## 실행 어라운드 패턴

- 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태의 코드

**파일에서 한 행을 읽는 코드**

```java
public String processFile() throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return br.readLine();
    }
}
```

### **동작 파라미터화**

- 현재 코드는 파일에서 한 번에 한 줄만 읽을 수 있다.
- 한 번에 두 줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 기존의 설정, 정리 과정은 재사용하고 processFile 메서드만 다른 동작을 수행하도록 processFile의 동작을 파라미터화하면 된다.

### 함수형 인터페이스를 이용해서 동작 전달

```java
@FunctionalInterface
public interface BufferedReaderProcessor {
    String process(BufferedReader b) throws IOException;
}
```

- 함수형 인터페이스 자리에 람다를 사용할 수 있다.
- BufferedReader → String과 IOException을 던질 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다.

```java
public String processFile(BufferedReaderProcessor p) throws IOException {
    ...
}
```

- 정의한 인터페이스를 processFile 메서드의 인수로 전달할 수 있다.

### 동작 실행

```java
public String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
        return p.process(br);
    }
}
```

- BufferedReaderProcessor에 정의된 process 메서드의 시그니처(BufferedReader → String)와 일치하는 람다를 전달할 수 있다.
- 람다 표현식으로 processFile 바디 내에서 BufferedReaderProcessor 객체의 process를 호출할 수 있다.

### 람다 전달

- 람다를 이용해 다양한 동작을 processFile 메서드로 전달할 수 있다.

**파일의 한 행을 처리**

```java
String oneLine = processFile((BufferedReader br) -> br.readLine());
```

**파일의 두 행을 처리**

```java
String twoLines = 
        processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

## 함수형 인터페이스 사용

- 다양한 람다 표현식을 사용하려면 공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요
- 자바 8에서 java.util.function 패키지로 여러 가지 새로운 함수형 인터페이스 제공

### Predicate

- test라는 추상 메서드를 정의
- 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환

**예제**

```java
@FunctionalInterface
public interface Predicate<T> { 
    boolean test(T t);
}

public <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> results = new ArrayList<>();
    for (T t : list) {
        if(p.test(t)) {
            results.add(t);
        }
    }
    return results;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```

### Consumer

- 제네릭 형식 T 객체를 받아서 void를 반환하는 accept라는 추상 메서드 정의

**예제**

```java
@FunctionalInterface
public interface Consumer<T> { 
    void accept(T t);
}

public <T> void forEach(List<T> list, Consumer<T> c) {
    for(T t : list) {
        c.accept(t);
    }
}

forEach(Arrays.asList(1,2,3,4,5), (Inteager i) -> System.out.println(i));
```

### Function

- 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply 정의

**예제**

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

public <T, R> List<R> map(List<T> list, Function<T, R> f) {
    List<R> result = new ArrayList<>();
    for(T t : list) {
        result.add(f.apply(t));
    }
    return result;
}

// [7, 2, 6]
List<Inteager> l = 
        map(Arrays.asList("lambdas", "in", "aciton"), (String s) -> s.length());
```

## 형식 검사, 형식 추론, 제약

### 형식 검사

- 람다가 사용되는 콘텍스트를 이용해 람다의 형식을 추론
- 어떤 콘텍스트에서 기대되는 람다 표현식의 형식을 **대상 형식**이라고 부름

**형식 검사 과정**

```java
List<Apple> heavierThan150g =
    filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```

위 코드의 형식 검사 과정은 다음과 같다.

1. filter 메서드의 선언을 확인한다.
2. filter 메서드는 두 번째 파라미터로 Predicate<Apple> 대상 형식을 기대한다.
3. Predicate<Apple>은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스다.
4. test 메서드는 Apple을 받아 boolean을 반환하는 함수 디스크립터를 묘사한다.
5. filter 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

### 형식 추론

- 자바 컴파일러는 람다 표현식이 사용된 콘텍스트(대상 형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다.
- 대상 형식을 이용해 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다.
- 결과적으로 컴파일러는 람다 표현식의 파라미터 형식을 추론할 수 있고, 람다 문법에서 이를 생략할 수 있다.

**Comparator 객체를 만드는 코드**

```java
// 형식을 추론하지 않음
Comparator<Apple> c =
    (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 형식을 추론함
Comparator<Apple> c =
    (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

- 어떤 방법이 좋은지 정해진 규칙은 없다. 상황에 따라 어떤 코드가 가독성을 향상시킬 수 있는지 결정해야 한다.

### 지역 변수 사용

- 람다 표현식에서는 **자유 변수**(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있다.
- 이와 같은 동작을 **람다 캡처링**이라고 부른다.

**지역 변수의 제약**

- 람다에서 참고하는 지역 변수는 final로 선언되어야 한다.
- 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다.
- 따라서 자바에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다.
- 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴다.

## 메서드 참조

### 개념

- 메서드 참조를 이용하면 기존의 메서드 정의를 재활용해서 람다처럼 전달할 수 있다.
- 메서드를 어떻게 호출해야 하는지 설명을 참조하는 게 아닌 메서드명을 직접 참조하는 것
- 메서드 명에 구분자(::)를 붙이는 방식으로 메서드 참조를 활용한다.

**람다와 메서드 참조 단축 표현**

| **람다** | **메서드 참조 단축 표현** |
| --- | --- |
| (Apple apple) → apple.getWeight() | Apple::getWeight |
| () → Thread.currentThread().dumpStack() | Thread.currentThread()::dumpStack |
| (str, i) → str.substring(i) | String::substring |
- 메서드 참조를 새로운 기능이 아닌 하나의 메서드를 참조하는 람다를 편리하게 표현할 수 있는 문법으로 간주할 수 있다.

### 메서드 참조를 만드는 방법

**메서드 참조의 세 가지 유형**

- **정적 메서드 참조**

    Integer의 parseInt 메서드는 Integer::parseInt로 표현 가능

- **다양한 형식의 인스턴스 메서드 참조**

    String의 length 메서드는 String::length로 표현 가능

- **기존 객체의 인스턴스 메서드 참조**

    Transaction 객체를 할당받는 expensiveTransaction 지역 변수가 있고, Transaction 객체에는 getValue 메서드가 있다면, 이를 expensiveTransaction::getValue라고 표현 가능


**세 가지 종류의 람다 표현식을 메서드 참조로 바꾸는 방법**

- 정적 메서드 참조

```java
(args) -> ClassName.staticMethod(args) // 람다
ClassName::staticMethod // 메서드 참조

```

- 디양한 형식의 인스턴스 메서드 참조

```java
(arg0, rest) -> arg0.instanceMethod(rest) // 람다
ClassName::instanceMethod // 메서드 참조
```

- 기존 객체의 인스턴스 메서드 참조

```java
(args) -> expr.instanceMethod(args) // 람다
expr::instanceMethod // 메서드 참조
```

### 생성자 참조

- ClassName::new처럼 클래스명과 new 키워드를 이용해서 기존 생성자의 참조를 만들 수 있다.
- 생성자 참조를 사용하려면 생성자 참조와 일치하는 시그니처를 갖는 함수형 인터페이스가 필요하다.

**인수가 없는 생성자 Supplier의 () → Apple과 같은 시그니처를 갖는 생성자**

```java
// 셍상지 침조
Supplier<Apple> c1 = Apple::new;
Apple a1 = c1.get();

// 람다 표현식
Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get();
```

# 4. 스트림 소개

## 스트림이란?

### 개념

- 스트림은 자바 8 API에 새로 추가된 기능으로, 스트림을 이용해 컬렉션 데이터를 선언형으로 처리 가능
- 선언형: 데이터를 SQL 질의 언어처럼 구현을 명시하지 않고 자동으로 처리
- 스트림을 이용하면 멀티스레드 코드를 사용하지 않고 데이터를 투명하게 병렬로 처리할 수 있음

### 스트림 사용 예시

**저칼로리의 요리명을 반환하고, 칼로리를 기준으로 요리를 정렬하는 코드**

```java
List<String> lowCaloricDishesName = menu.stream()
            .filter(d -> d.getCalories() < 400)   // 400 칼로리 이하의 요리 선택
            .sorted(comparing(Dish::getCalories)) // 칼로리로 요리 정렬
            .map(Dish::getName)                   // 요리명 추출
            .toList();                            // 모든 요리명을 리스트에 저장
```

**parallelStream()을 사용한 병렬 처리**

```java
List<String> lowCaloricDishesName = menu.parallelStream()
            .filter(d -> d.getCalories() < 400)   // 400 칼로리 이하의 요리 선택
            .sorted(comparing(Dish::getCalories)) // 칼로리로 요리 정렬
            .map(Dish::getName)                   // 요리명 추출
            .toList();                            // 모든 요리명을 리스트에 저장
```

### 스트림 API 특징

- **선언형**: 더 간결하고 가독성이 좋아진다.
- **조립할 수 있음:** filter, sorted, map, collect 같은 고수준 빌딩 블록을 연결해 복잡한 데이터 처리 파이프라인을 만들 수 있다. 유연성이 좋아진다.
- **병렬화**: 고수준 빌딩 블록을 사용하면 스레드와 락 없이 데이터 처리 과정을 병렬화 할 수 있다. 성능이 좋아진다.

## 스트림 시작하기

### 스트림 정의

- 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소

**연속된 요소**

- 컬렉션처럼 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스
- 컬렉션
    - 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룸
    - 컬렉션 주제: 데이터
- 스트림
    - filter, sorted 같은 표현 계산식이 주를 이룸
    - 스트림의 주제: 계산

**소스**

- 스트림은 컬렉션, 배열 등 데이터 제공 소스로부터 데이터를 소비
- 정렬된 컬렉션으로 스트림을 생성하면 스트림의 정렬이 유지됨

**데이터 처리 연산**

- 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산 지원
- 연산을 순차적 또는 병렬로 실행
- ex) filter, map, sorted, …

### 스트림 주요 특징

**파이프라이닝**

- 스트림끼리 연결해서 커다란 파이프라인 구성할 수 있도록 스트림 자신을 반환
- 게으름, 쇼트서킷 같은 최적화 가능

**내부 반복**

- 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리, 스트림은 내부 반복을 지원

### 예제

**세 개의 고칼로리 메뉴를 필터링**

```java
List<String> threeHighCaloricDishNames = menu.stream()  // 메뉴(요리 리스트)에서 스트림을 얻는다.
        .filter(dish -> dish.getCalories() > 300) // 파이프라인 연산 만들기, 첫 번째로 고칼로리 요리를 필터링한다.
        .map(Dish::getName) // 요리명 추출
        .limit(3) // 선착순 세 개만 선택
        .collect(toList()); //결과를 다른 리스트로 저장
```

- 요리 리스트인 데이터 소스가 연속된 요소를 스트림에 제공
- filter, map, limit, collect로 이어지는 일련의 데이터 처리 연산 적용
- collect를 제외한 모든 연산은 서로 파이프라인을 형성할 수 있도록 스트림 반환
- 최종적으로 collect 연산으로 파이프라인 처리, 결과 반환

**일련의 스트림 연산이 적용되는 과정**

- filter: 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다.
- map: 람다를 이용해 한 요소를 다른 요소로 변환하거나 정보를 추출
- limit: 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소
- collect: 스트림을 다른 형식으로 변환

## 스트림과 컬렉션

### 차이점

- 가장 큰 차이: 데이터를 **언제** 계산하느냐
- 컬렉션: 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다. (메모리에 저장 필요)
- 스트림: 요청할 때만 요소를 계산한다. (스트림에 요소를 추가/제거 할 수 없다)

**생산자 소비자 관계**

- 스트림은 사용자가 요청하는 값만 스트림에서 추출한다. 스트림은 게으르게 만들어지는 컬렉션과 같다.
- 사용자 입장에서는 변화를 알 수 없으며, 이를 생산자 소비자 관계라고 한다.

**생산자 중심**

- 스트림과 달리 컬렉션은 적극적으로 생성된다.
- 요소를 사용하지 않아도 그 값이 생성되어 있어야 한다. 이를 생산자 중심이라 한다.

### 딱 한 번만 탐색할 수 있다

- 스트림은 딱 한 번만 탐색할 수 있다. 탐색된 스트림의 요소는 소비된다.
- 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

### 외부 반복과 내부 반복

**외부 반복**

- 사용자가 직접 요소를 반복하는 것
- 컬렉션에서 사용

컬렉션: 반복자를 사용한 외부 반복

```java
List<String> names = new ArrayList<>();
for (Dish dish : menu) {
    names.add(dish.getName());
}
```

**내부 반복**

- 반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장
- 스트림에서 사용

스트림: 내부 반복

```java
List<String> names = menu.stream()
        .map(Dish::getName)
        .collect(toList());
```

**내부 반복의 이점**

- 외부 반복에서는 명시적으로 컬렉션 항목을 하나씩 가져와서 처리해야 하며, 병렬성을 스스로 관리해야 한다
- 내부 반복을 이용하면 모든 데이터를 한번에 처리가 가능하다. 또한 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.
- 내부 반복을 사용하면 반복 과정을 우리가 신경 쓰지 않아도 된다.

## 스트림 연산

### 중간 연산

- 연결할 수 있는 스트림 연산
- 최종 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다 (게으르다)
- ex) filter, map, limit, …

**게으른 특성으로 얻을 수 있는 최적화 효과**

- 쇼트서킷
- 루프 퓨전: 서로 다른 연산을 한 과정으로 병합

### 최종 연산

- 스트림을 닫는 최종 연산으로, 스프림 파이프라인에서 결과를 도출
- List, Integer, void 등 스트림 이외의 결과 반환
- ex) collect, forEach, …

### 중간 연산, 최종 연산 요약

**중간 연산**

| 연산 | 형식 | 반환 형식 | 연산의 인수 | 함수 디스크립터 |
| --- | --- | --- | --- | --- |
| filter | 중간 연산 | Stream<T> | Predicate<T> | T → boolean |
| map | 중간 연산 | Stream<T> | Function<T,R> | T → R |
| limit | 중간 연산 | Stream<T> |  |  |
| sorted | 중간 연산 | Stream<T> | Comparator<T> | (T, T) → int |
| distinct | 중간 연산 | Stream<T> |  |  |

**최종 연산**

| 연산 | 형식 | 반환 형식 | 목적 |
| --- | --- | --- | --- |
| forEach | 최종 연산 | void | 스트림의 각 요소를 소비하면서 람다를 적용한다. |
| count | 최종 연산 | long (generic) | 스트림의 요소 개수를 반환한다. |
| collect | 최종 연산 |  | 스트림을 리듀스해서 리스트, 맵, 정수 형식의 컬렉션을 만든다. (6장 참조) |

### 스트림 이용 과정

- 질의를 수행할 (컬렉션 같은) 데이터 소스
- 스트림 파이프라인을 구성할 중간 연산 연결
- 스트림 파이프라인을 실행하고 결과를 만들 최종 연산