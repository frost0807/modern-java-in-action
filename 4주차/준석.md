## 5장. 스트림 활용

## 5.1 필터링

### 프레디케이트로 필터링

스트림 인터페이스는 `filter` 메서드를 지원함. 이 메서드는 **프레디케이트**(불리언을 반환하는 함수)를 인수로 받아서 일치하는 모든 요소를 포함하는 스트림을 반환함.

```java
List vegetarianMenu = menu.stream()
    .filter(Dish::isVegetarian)
    .collect(toList());
```

### 고유 요소 필터링

스트림은 고유 요소로 이루어진 스트림을 반환하는 `distinct` 메서드도 지원함. 이때 고유 여부는 스트림에서 만든 객체의 `hashCode`, `equals`로 결정됨.

```java
List numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
    .filter(i -> i % 2 == 0)
    .distinct()
    .forEach(System.out::println);  // 2, 4
```

---

## 5.2 스트림 슬라이싱

### 프레디케이트를 이용한 슬라이싱

#### TAKEWHILE

리스트가 정렬되어 있는 경우, 크기가 큰 스트림에 유용하게 사용할 수 있음. `takeWhile`을 활용하여 조건이 참이 아닐 경우 바로 거기서 멈추도록 할 수 있음.

```java
List slicedMenu1 = specialMenu.stream()
    .takeWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

#### DROPWHILE

`takeWhile`과 반대로 동작함. 나머지 연산이라고도 볼 수 있으며, 참인 부분을 버리다가 처음으로 거짓인 부분이 나오면 그 뒤 남은 부분을 모두 반환해줌.

```java
List slicedMenu2 = specialMenu.stream()
    .dropWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

### 스트림 축소

스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 `limit(n)` 메서드를 지원함. 스트림이 정렬되어 있으면 최대 요소 n개를 반환할 수 있음.

```java
List dishes = specialMenu.stream()
    .filter(dish -> dish.getCalories() > 300)
    .limit(3)
    .collect(toList());
```

### 요소 건너뛰기

스트림은 처음 n개 요소를 제외한 스트림을 반환하는 `skip(n)` 메서드를 지원함. n개 이하의 요소를 포함하는 스트림에 `skip(n)`을 호출하면 빈 스트림이 반환됨. offset과 비슷하다고도 볼 수 있음.

```java
List dishes = menu.stream()
    .filter(d -> d.getCalories() > 300)
    .skip(2)
    .collect(toList());
```

---

## 5.3 매핑

### 스트림의 각 요소에 함수 적용하기

스트림은 함수를 인수로 받는 `map` 메서드를 지원함. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑됨 (기존 값을 고치는 것보다는 새로운 버전을 만든다는 개념에 가까움).

```java
List dishNames = menu.stream()
    .map(Dish::getName)
    .collect(toList());

List dishNameLengths = menu.stream()
    .map(Dish::getName)
    .map(String::length)
    .collect(toList());
```

### 스트림 평면화

`flatMap`은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑함. 즉, `map(Arrays::stream)`과 달리 `flatMap`은 하나의 평면화된 스트림을 반환함.

```java
// ["Hello", "World"] → ["H", "e", "l", "o", "W", "r", "d"]
List uniqueCharacters = words.stream()
    .map(word -> word.split(""))
    .flatMap(Arrays::stream)
    .distinct()
    .collect(toList());
```

`flatMap` 메서드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행함.

---

## 5.4 검색과 매칭

### anyMatch - 프레디케이트가 적어도 한 요소와 일치하는지 확인

```java
if (menu.stream().anyMatch(Dish::isVegetarian)) {
    System.out.println("The menu is (somewhat) vegetarian friendly!");
}
```

`anyMatch`는 불리언을 반환하므로 최종 연산임.

### allMatch - 프레디케이트가 모든 요소와 일치하는지 검사

```java
boolean isHealthy = menu.stream()
    .allMatch(dish -> dish.getCalories() < 1000);
```

### noneMatch - allMatch와 반대 연산

`noneMatch`는 주어진 프레디케이트와 일치하는 요소가 없는지 확인함.

```java
boolean isHealthy = menu.stream()
    .noneMatch(d -> d.getCalories() >= 1000);
```

### 쇼트서킷

`anyMatch`, `noneMatch`, `allMatch` 세 메서드는 스트림 쇼트서킷 기법을 활용함. 즉, 자바의 `&&`, `||`와 같은 연산을 활용함. 쇼트서킷은 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있음. 마찬가지로 `limit`도 쇼트서킷 연산임.

### findAny - 요소 검색

`findAny` 메서드는 현재 스트림에서 임의의 요소를 반환함.

```java
Optional dish = menu.stream()
    .filter(Dish::isVegetarian)
    .findAny();
```

### findFirst - 첫 번째 요소 찾기

리스트 또는 정렬된 연속 데이터로부터 생성된 스트림처럼 논리적인 아이템 순서가 정해져 있을 수 있음. 첫 번째 요소를 찾으려면 `findFirst()`를 사용함.

```java
Optional firstSquareDivisibleByThree = someNumbers.stream()
    .map(n -> n * n)
    .filter(n -> n % 3 == 0)
    .findFirst();
```

**findFirst와 findAny가 모두 필요한 이유**: 병렬성 때문임. 병렬 실행에서는 첫 번째 요소를 찾기 어려움. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 `findAny`를 사용함.

---

## 5.5 리듀싱

이 절에서는 리듀스 연산을 이용해서 스트림 요소를 조합해서 더 복잡한 질의를 표현하는 방법을 살펴봄. 이러한 질의를 수행하려면 Integer 같은 결과가 나올 때까지 스트림의 모든 요소를 반복적으로 처리해야 함. 이러한 질의를 **리듀싱 연산**(모든 스트림 요소를 처리해서 값으로 반환)이라고 함. 함수형 프로그래밍 언어 용어로는 이 과정이 마치 종이를 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다는 의미로 **폴드(fold)**라고 부름.

### 요소의 합

```java
// for-each 루프를 이용
int sum = 0;
for (int x : numbers) {
    sum += x;
}

// reduce를 이용한 연산
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
// 초기값 0
// 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator
// 메서드 참조를 이용해 더 간결하게
int sum = numbers.stream().reduce(0, Integer::sum);
```

### 초기값이 없는 경우

그러나 이 `reduce`는 `Optional` 객체를 반환함. 스트림에 아무 요소도 없는 상황이 있다면 초기값이 없으므로 `reduce`는 합계를 반환할 수 없음. 따라서 합계가 없음을 가리킬 수 있도록 `Optional` 객체로 감싼 결과를 반환함.

```java
Optional sum = numbers.stream().reduce((a, b) -> a + b);
```

### 최댓값과 최솟값

최댓값과 최솟값을 찾을 때도 `reduce`를 활용할 수 있음.

```java
Optional max = numbers.stream().reduce(Integer::max);
Optional min = numbers.stream().reduce(Integer::min);
// Integer::min 대신 (x, y) -> x < y ? x : y 를 사용해도 무방하지만 가독성이 더 좋음
```

### map과 reduce를 연결하는 기법 - 맵 리듀스 패턴

`map`과 `reduce` 메서드를 연결하는 방법을 **맵 리듀스 패턴**이라고 함. 쉽게 병렬화하는 특징 덕분에 구글이 웹 검색에서 적용하면서 유명해짐.

```java
int count = menu.stream()
    .map(d -> 1)
    .reduce(0, (a, b) -> a + b);
```

`reduce`를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 `reduce`를 실행할 수 있게 됨. 반복적인 합계에서는 sum 변수를 공유해야 하므로 쉽게 병렬화하기 어려움.

---

## 5.7 숫자형 스트림

### 기본형 특화 스트림

자바 8에서는 세 가지 기본형 특화 스트림을 제공함: `IntStream`, `LongStream`, `DoubleStream`. 각각의 인터페이스는 `sum`, `max`와 같이 자주 사용하는 숫자 관련 리듀싱 연산 수행 메서드를 제공함.

```java
// 기본형 특화 스트림으로 변환
int calories = menu.stream()
    .mapToInt(Dish::getCalories)
    .sum();

// 객체 스트림으로 복원
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream stream = intStream.boxed();
```

### 숫자 범위

자바 8의 `IntStream`과 `LongStream`에서는 `range`와 `rangeClosed`라는 두 가지 정적 메서드를 제공함.

```java
IntStream evenNumbers = IntStream.rangeClosed(1, 100)
    .filter(n -> n % 2 == 0);
System.out.println(evenNumbers.count());  // 50개
```

`range`는 시작값과 종료값이 결과에 포함되지 않는 반면 `rangeClosed`는 시작값과 종료값이 결과에 포함됨.

---

## 5.8 스트림 만들기

### 값으로 스트림 만들기

```java
Stream stream = Stream.of("Modern", "Java", "In", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);

// 빈 스트림
Stream emptyStream = Stream.empty();
```

### 배열로 스트림 만들기

```java
int[] numbers = {2, 3, 5, 7, 11, 13};
int sum = Arrays.stream(numbers).sum();
```

### 파일로 스트림 만들기

```java
long uniqueWords = 0;
try (Stream lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
    uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" ")))
        .distinct()
        .count();
} catch (IOException e) {
    // 예외 처리
}
```

### 무한 스트림 만들기

`Stream.iterate`와 `Stream.generate`를 이용해서 무한 스트림을 만들 수 있음.

```java
// iterate
Stream.iterate(0, n -> n + 2)
    .limit(10)
    .forEach(System.out::println);

// generate
Stream.generate(Math::random)
    .limit(5)
    .forEach(System.out::println);
```

---

## 6장. 스트림으로 데이터 수집

## 6.1 컬렉터란 무엇인가?

`Collectors` 유틸리티 클래스는 자주 사용하는 컬렉터 인스턴스를 손쉽게 생성할 수 있는 정적 메서드를 제공함. `Collectors`에서 제공하는 메서드의 기능은 크게 세 가지로 구분됨:

1. **스트림 요소를 하나의 값으로 리듀스하고 요약**: 트랜잭션의 총합 등 다양한 계산을 수행할 때 유용하게 사용
2. **요소 그룹화**: 다수준으로 그룹화 혹은 각각의 결과 서브그룹에 추가로 리듀싱 연산을 적용할 수 있도록 다양한 컬렉터 조합하는 방식
3. **요소 분할**: 한 개의 인수를 받아 불리언을 반환하는 함수, 즉 프레디케이트를 그룹화 함수로 사용

```java
import static java.util.stream.Collectors.*;
```

### 컬렉터로 스트림의 항목을 컬렉션으로 재구성

```java
// 예전 방식
Map> transactionsByCurrencies = new HashMap<>();
for (Transaction transaction : transactions) {
    Currency currency = transaction.getCurrency();
    List transactionsForCurrency = transactionsByCurrencies.get(currency);
    if (transactionsForCurrency == null) {
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies.put(currency, transactionsForCurrency);
    }
    transactionsForCurrency.add(transaction);
}

// Stream에 collect를 사용하는 방식
Map> transactionsByCurrencies =
    transactions.stream().collect(groupingBy(Transaction::getCurrency));
```

---

## 6.2 리듀싱과 요약

### 스트림값에서 최댓값과 최솟값 검색

```java
Comparator dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
Optional mostCalorieDish = menu.stream()
    .collect(maxBy(dishCaloriesComparator));
```

메뉴가 비어있을 때를 대비해서 `Optional<Dish>`로 구현함.

### 요약 연산

`Collectors` 클래스는 `Collectors.summingInt`라는 특별한 요약 팩토리 메서드를 제공함.

```java
// 메뉴 리스트의 총 칼로리 계산
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));

// 평균값 계산
double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));

// 요소 수, 합계, 평균, 최댓값, 최솟값 등을 한 번에 계산
IntSummaryStatistics menuStatistics = menu.stream()
    .collect(summarizingInt(Dish::getCalories));
// IntSummaryStatistics{count=9, sum=4300, min=120, average=477.777778, max=800}
```

### 문자열 연결

`joining` 팩토리 메서드를 이용하면 스트림의 각 객체에 `toString` 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환함.

```java
String shortMenu = menu.stream().map(Dish::getName).collect(joining(", "));
```

### 범용 리듀싱 요약 연산

위의 모든 컬렉터는 `reducing` 팩토리 메서드로도 정의할 수 있음.

```java
int totalCalories = menu.stream()
    .collect(reducing(0, Dish::getCalories, (i, j) -> i + j));

// 한 개의 인수를 가진 reducing
Optional mostCalorieDish = menu.stream()
    .collect(reducing((d1, d2) -> d1.getCalories() > d2.getCalories() ? d1 : d2));
```

---

## 6.3 그룹화

자바 8의 함수형을 이용하면 가독성 있는 한 줄 코드로 그룹화를 구현할 수 있음. 팩토리 메서드 `Collectors.groupingBy`를 이용해서 쉽게 메뉴를 그룹화할 수 있음.

```java
Map> dishesByType = menu.stream()
    .collect(groupingBy(Dish::getType));
// {FISH=[prawns, salmon], OTHER=[french fries, rice, pizza], MEAT=[pork, beef, chicken]}
```

스트림의 각 요리에서 `Dish.Type`과 일치하는 모든 요리를 추출하는 함수를 `groupingBy` 메서드로 전달함. 이 함수를 **분류 함수**라고 부름.

### 그룹화된 요소 조작

```java
// 500 칼로리가 넘는 요리만 필터링하여 타입별로 그룹화
Map> caloricDishesByType = menu.stream()
    .filter(dish -> dish.getCalories() > 500)
    .collect(groupingBy(Dish::getType));
```

위 코드의 문제점: FISH 종류 요리가 필터링 과정에서 없어지면서 결과 맵에 해당 키 자체가 사라짐.

```java
// Collectors.filtering을 사용한 해결방법
Map> caloricDishesByType = menu.stream()
    .collect(groupingBy(Dish::getType,
        filtering(dish -> dish.getCalories() > 500, toList())));
```

### 다수준 그룹화

`groupingBy`를 두 번 사용해서 다수준으로 그룹화할 수 있음.

```java
Map>> dishesByTypeCaloricLevel = menu.stream()
    .collect(groupingBy(Dish::getType,  // 첫 번째 수준의 분류 함수
        groupingBy(dish -> {  // 두 번째 수준의 분류 함수
            if (dish.getCalories() <= 400) return CaloricLevel.DIET;
            else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
            else return CaloricLevel.FAT;
        })
    ));
```

### 서브그룹으로 데이터 수집

일반적으로 스트림에서 같은 그룹으로 분류된 모든 요소에 리듀싱 작업을 수행할 때는 팩토리 메서드 `groupingBy`에 두 번째 인수로 전달한 컬렉터를 사용함.

```java
// 메뉴의 요리 타입별 칼로리 합계
Map totalCaloriesByType = menu.stream()
    .collect(groupingBy(Dish::getType,
        summingInt(Dish::getCalories)));
```

### collectingAndThen

팩토리 메서드 `collectingAndThen`은 적용할 컬렉터와 변환함수를 인수로 받아 다른 컬렉터를 반환함.

```java
// 각 타입별로 가장 높은 칼로리를 가진 요리 찾기
Map mostCaloricByType = menu.stream()
    .collect(groupingBy(Dish::getType,
        collectingAndThen(
            maxBy(comparingInt(Dish::getCalories)),
            Optional::get)));
```

`groupingBy` 컬렉터는 스트림의 첫 번째 요소를 찾은 이후에야 (`Optional.get()`) 그룹화 맵에 새로운 키를 게으르게 추가함. 따라서 리듀싱 컬렉터는 `Optional` 래퍼를 사용할 필요가 없음.

---

## 6.4 분할

**분할**은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능임. 분할 함수는 불리언을 반환하므로 맵의 키 형식은 `Boolean`이며, 참 또는 거짓을 갖는 두 개의 그룹으로 분류됨.

```java
// 채식주의자 친구를 위한 채식인지 아닌지 분류
Map> partitionedMenu = menu.stream()
    .collect(partitioningBy(Dish::isVegetarian));
// {false=[pork, beef, chicken, prawns, salmon], true=[french fries, rice, pizza]}

List vegetarianDishes = partitionedMenu.get(true);
```

### 분할의 장점

분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다는 것이 분할의 장점임.

### 다수준 분할

```java
// 채식 요리와 채식이 아닌 요리를 각각 그룹으로 나눈 다음 타입별로 그룹화
Map>> vegetarianDishesByType = menu.stream()
    .collect(partitioningBy(Dish::isVegetarian,
        groupingBy(Dish::getType)));
// {false={FISH=[prawns, salmon], MEAT=[pork, beef, chicken]},
//  true={OTHER=[french fries, rice, pizza]}}
```

---

## 6.5 Collector 인터페이스

`Collector` 인터페이스는 리듀싱 연산(즉, 컬렉터)을 어떻게 구현할지 제공하는 메서드 집합으로 구성됨.

```java
public interface Collector {
    Supplier supplier();
    BiConsumer accumulator();
    BinaryOperator combiner();
    Function finisher();
    Set characteristics();
}
```

- **T**: 수집될 스트림 항목의 제네릭 형식
- **A**: 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식
- **R**: 수집 연산 결과 객체의 형식 (대개 컬렉션 형식)

### Collector 인터페이스의 메서드

#### supplier 메서드: 새로운 결과 컨테이너 만들기

`supplier` 메서드는 빈 결과로 이루어진 `Supplier`를 반환해야 함. 즉, 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수.

```java
public Supplier<List> supplier() {
    return () -> new ArrayList();
}
// 또는
public Supplier<List> supplier() {
    return ArrayList::new;
}
```

#### accumulator 메서드: 결과 컨테이너에 요소 추가하기

`accumulator` 메서드는 리듀싱 연산을 수행하는 함수를 반환함.

```java
public BiConsumer<List, T> accumulator() {
    return (list, item) -> list.add(item);
}
// 또는
public BiConsumer<List, T> accumulator() {
    return List::add;
}
```

#### finisher 메서드: 최종 변환값을 결과 컨테이너로 적용하기

`finisher` 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 함.

```java
public Function<List, List> finisher() {
    return Function.identity();
}
```

#### combiner 메서드: 두 결과 컨테이너 병합

`combiner` 메서드는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의함. 스트림을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할함.

```java
public BinaryOperator<List> combiner() {
    return (list1, list2) -> {
        list1.addAll(list2);
        return list1;
    };
}
```

#### Characteristics 메서드

`Characteristics` 메서드는 컬렉터의 연산을 정의하는 `Characteristics` 형식의 불변 집합을 반환함. `Characteristics`는 스트림을 병렬로 리듀스할 것인지 그리고 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트를 제공함.

`Characteristics`는 다음 세 항목을 포함하는 열거형:

- **UNORDERED**: 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않음
- **CONCURRENT**: 다중 스레드에서 `accumulator` 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있음. 컬렉터의 플래그에 `UNORDERED`를 함께 설정하지 않으면 데이터 소스가 정렬되어 있지 않은 상황에서만 병렬 리듀싱을 수행할 수 있음
- **IDENTITY_FINISH**: `finisher` 메서드가 반환하는 함수는 단순히 `identity`를 적용할 뿐이므로 생략 가능. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있음
