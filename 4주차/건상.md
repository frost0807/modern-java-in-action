# 05. 스트림 활용

## 필터링

### predicate 사용

```jsx
Stream<T> filter(Predicate<? super T> predicate);
```

### 고유 요소

```jsx
Stream<T> distinct();
```

## 스트림 슬라이싱

### predicate 사용

```jsx
Stream<T> takeWhile(Predicate<? super T> predicate);
Stream<T> dropWhile(Predicate<? super T> predicate);
```

### 스트림 축소

```jsx
Stream<T> limit(long maxSize);
```

### 요소 건너뛰기

```jsx
Stream<T> skip(long n);
```

## 매핑

기존의 값을 ‘고친다(modify)’보다는 ‘새로운 값을 만든다’에 가까우므로 ‘변환(transforming)’에 가까운 ‘매핑(mapping)’이라는 단어 사용

### 스트림 각 요소에 함수 적용

```jsx
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
```

### 스트림 평면화

```jsx
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
```

## 검색과 매칭

### 매칭

```jsx
// 요소 중 1개라도 일치
boolean anyMatch(Predicate<? super T> predicate);
// 전부 일치
boolean allMatch(Predicate<? super T> predicate);
// 전부 불일치
boolean noneMatch(Predicate<? super T> predicate);
```

### 검색

```jsx
Optional<T> findAny();
```

### 첫 번째 요소

```jsx
Optional<T> findFirst();
```

## 리듀싱

결과값을 위해서 스트림의 모든 요소를 처리

### 요소의 합

```jsx
Optional<T> reduce(BinaryOperator<T> accumulator);

T reduce(T identity, BinaryOperator<T> accumulator);

<U> U reduce(U identity,
             BiFunction<U, ? super T, U> accumulator,
             BinaryOperator<U> combiner);
```

## 숫자형 스트림

### 기본형 특화 스트림

IntStream, DoubleStream, LongStream

```jsx
IntStream mapToInt(ToIntFunction<? super T> mapper);
Stream<Integer> boxed();
```

### Optional

OptinalInt, OptionalDouble, OptionalLong

### 숫자 범위

```jsx
public static IntStream range(int startInclusive, int endExclusive)
public static IntStream rangeClosed(int startInclusive, int endInclusive)
```

## 스트림 만들기

### 값으로 스트림 만들기

```jsx
public static<T> Stream<T> of(T t)
public static<T> Stream<T> of(T... values) // Arrays.stream(values);
public static<T> Stream<T> empty()
```

### Nullable

```jsx
public static<T> Stream<T> ofNullable(T t)
```

### 배열로 스트림 만들기

```jsx
//Arrays
public static <T> Stream<T> stream(T[] array) {
    return stream(array, 0, array.length);
}
public static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive) {
    return StreamSupport.stream(spliterator(array, startInclusive, endExclusive), false);
}
```

### 파일로 스트림 만들기

java.nio.file.Files

### 함수로 무한 스트림 만들기

```jsx
static public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
public static<T> Stream<T> iterate(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next)
```

### generate 메서드

```jsx
public static<T> Stream<T> generate(Supplier<? extends T> s)
```

**쇼트서킷 평가**

전체 스트림 처리하지 않고도 결과를 반환

**Optional**

값이 존재하는지 확인하고 값이 없을 때 어떻게 처리할지 강제하는 기능 제공

**스트림 연산 : 상태 있음과 상태 없음**

map, filter 입력 스트림에서 각 요소별 결과를 출력 스트림으로 보냄

reduce, sum, max 과거 처리한 결과를 누적할 내부 상태가 필요

sorted, distinct 정렬, 중복 제거 하려면 과거 이력을 알아야 하므로 내부 상태를 갖는 연산

---

# 06. 스트림으로 데이터 수집

## 리듀싱과 요약

### count

```jsx
public static <T> Collector<T, ?, Long> counting()
```

### 최대/최소

```jsx
public static <T> Collector<T, ?, Optional<T>> maxBy(Comparator<? super T> comparator)
public static <T> Collector<T, ?, Optional<T>> minBy(Comparator<? super T> comparator)
```

### 요약

```jsx
public static <T> Collector<T, ?, Integer> summingInt(ToIntFunction<? super T> mapper)
public static <T> Collector<T, ?, Long> summingLong(ToLongFunction<? super T> mapper)
public static <T> Collector<T, ?, Double> summingDouble(ToDoubleFunction<? super T> mapper)

```

### 문자열 연결

```jsx
public static Collector<CharSequence, ?, String> joining()
public static Collector<CharSequence, ?, String> joining(CharSequence delimiter)
public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)
```

### 리듀싱

```jsx
public static <T> Collector<T, ?, Optional<T>> reducing(BinaryOperator<T> op)
public static <T> Collector<T, ?, T> reducing(T identity, BinaryOperator<T> op)
```

## 그룹화

### 다수준 그룹화

```jsx
public static <T, K> Collector<T, ?, Map<K, List<T>>>
groupingBy(Function<? super T, ? extends K> classifier)
public static <T, K, A, D>
Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
                                      Collector<? super T, A, D> downstream)
public static <T, K, D, A, M extends Map<K, D>>
Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier,
                              Supplier<M> mapFactory,
                              Collector<? super T, A, D> downstream)
```

### 컬렉터 결과를 다른 형식에 적용

```jsx
public static<T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream,
                                                            Function<R,RR> finisher)
```

## 분할

```jsx
public static <T> Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate)
public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate, Collector<? super T, A, D> downstream)
```

## Collector 인터페이스

supplier : 새로운 결과 컨테이너 만들기

accumulator : 결과 컨테이너에 요소 추가

finisher : 최종 변환값을 결과 컨테이너로 적용

combiner : 두 결과 컨테이너 병합

characterristics

- UNORDERED : 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향 받지 않음
- CONCURRENT : 다중 스레드에서 accumulator 함수를 동시에 호출 가능 (병렬 리듀싱 수행 가능)
- IDENTITY_FINISH : finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐이므로 이를 생략 가능
